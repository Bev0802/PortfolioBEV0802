## Эрик Фримен, Элизабет Фримен "Паттерны проектирования"


### Основные тезисы в таблице:

| **Паттерн**            | **Описание**                                                                                   | **Основные тезисы**                                                                                                              | **Пример**                                                                                               |
|------------------------|-----------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|
| **Strategy**           | Определяет семейство алгоритмов, инкапсулирует их и делает их взаимозаменяемыми.                | Позволяет изменять алгоритмы независимо от клиента. Поддерживает открытость/закрытость.                                         | `interface Strategy { void execute(); }`<br>`class ConcreteStrategyA implements Strategy { public void execute() { // implementation } }` |
| **Observer**           | Позволяет объектам оповещать другие объекты о изменениях.                                     | Обеспечивает механизмы подписки и уведомления. Подходит для ситуаций с множественными зависимостями.                            | `class Subject { private List<Observer> observers = new ArrayList<>(); public void addObserver(Observer o) { observers.add(o); } }` |
| **Decorator**          | Добавляет функциональность объектам динамически.                                             | Позволяет расширять возможности объектов без изменения их кода. Упрощает поддержку расширений.                                 | `class Coffee { public int cost() { return 5; } }`<br>`class MilkDecorator extends Coffee { public int cost() { return super.cost() + 2; } }` |
| **Factory Method**     | Определяет интерфейс для создания объекта, но позволяет подклассам изменять тип создаваемого объекта. | Упрощает создание объектов, позволяя подкладам управлять процессом создания.                                                      | `abstract class Creator { abstract Product factoryMethod(); }`<br>`class ConcreteCreator extends Creator { Product factoryMethod() { return new ConcreteProduct(); } }` |
| **Singleton**          | Обеспечивает создание единственного экземпляра класса.                                         | Гарантирует, что существует только один экземпляр класса и предоставляет глобальную точку доступа к нему.                       | `public class Singleton { private static Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }` |
| **Command**            | Превращает запросы в объекты, которые можно параметризовать, хранить и передавать.             | Обеспечивает инкапсуляцию всех деталей запроса в объекте. Поддерживает отмену и повторное выполнение запросов.                    | `interface Command { void execute(); }`<br>`class LightOnCommand implements Command { private Light light; public LightOnCommand(Light light) { this.light = light; } public void execute() { light.turnOn(); } }` |
| **Adapter**            | Преобразует интерфейс одного класса в интерфейс, который ожидает другой класс.                  | Позволяет несовместимым интерфейсам работать вместе. Делает существующий интерфейс совместимым с новым.                           | `class Adapter implements Target { private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } public void request() { adaptee.specificRequest(); } }` |
| **Facade**             | Предоставляет простой интерфейс к сложной системе.                                            | Упрощает взаимодействие с системой, скрывая сложные детали реализации за простым интерфейсом.                                    | `class ComputerFacade { private CPU cpu; private Memory memory; private Disk disk; public void startComputer() { cpu.freeze(); memory.load(BOOT_ADDRESS, disk.read(MEMORY_ADDRESS, DATA_SIZE)); cpu.jump(BOOT_ADDRESS); cpu.execute(); } }` |
| **Proxy**              | Предоставляет суррогатный или заполняющий объект для другого объекта.                         | Контролирует доступ к объекту, может делать запросы на основе состояния и защитить объект от злоупотреблений.                     | `interface Image { void display(); }`<br>`class RealImage implements Image { public void display() { // display image } }`<br>`class ProxyImage implements Image { private RealImage realImage; public void display() { if (realImage == null) { realImage = new RealImage(); } realImage.display(); } }` |

